### 一、转换数据

#### 1.1 哑变量

- 数据分析模型中有相当一部分的算法模型都要求输入的特征为数值型，但实际数据中特征的类型不一定只有数值型，还会存在相当一部分的类别型，这部分的特征需要经过哑变量处理才可以放入模型之中。哑变量处理的原理示例如图。
  ![image-20200312223548296](C:\Users\tiger\AppData\Roaming\Typora\typora-user-images\image-20200312223548296.png)
- get_dummies函数对类别型特征进行哑变量处理
- *pandas.***get_dummies***(data, prefix=None,* *prefix_sep**='_',* *dummy_na**=False, columns=None, sparse=False,* *drop_first**=False)*
- 对于一个类别型特征，若其取值有m个，则经过哑变量处理后就变成了m个`二元特征`，并且这些特征互斥，每次只有一个激活，这使得数据变得稀疏。
- 对类别型特征进行哑变量处理主要解决了部分算法模型无法处理类别型数据的问题，这在一定程度上起到了扩充特征的作用。由于数据变成了稀疏矩阵的形式，因此也加速了算法模型的运算速度。

| **参数名称** | **说明**                                                     |
| ------------ | ------------------------------------------------------------ |
| data         | 接收array、DataFrame或者Series。表示需要哑变量处理的数据。无默认。 |
| prefix       | 接收string、string的列表或者string的dict。表示哑变量化后列名的前缀。默认为None。 |
| prefix_sep   | 接收string。表示前缀的连接符。默认为‘_’。                    |
| dummy_na     | 接收boolean。表示是否为Nan值添加一列。默认为False。          |
| columns      | 接收类似list的数据。表示DataFrame中需要编码的列名。默认为None，表示对所有object和category类型进行编码。 |
| sparse       | 接收boolean。表示虚拟列是否是稀疏的。默认为False。           |
| drop_first   | 接收boolean。表示是否通过从k个分类级别中删除第一级来获得k-1个分类级别。默认为False。 |

```python
pd.get_dummies['dishes_name']  #哑变量处理
```

#### 1.2 离散化（连续型-->离散型）

- 某些模型算法，特别是某些分类算法如ID3决策树算法和Apriori算法等，要求数据是离散的，此时就需要将连续型特征（数值型）变换成离散型特征（类别型）。

- 连续特征的离散化就是在数据的取值范围内设定若干个离散的划分点，将取值范围划分为一些离散化的区间，最后用不同的符号或整数值代表落在每个子区间中的数据值。

- 因此离散化涉及两个子任务，即确定分类数以及如何将连续型数据映射到这些类别型数据上。其原理如图。

##### 1.2.1 等宽法

- 将数据的值域分成具有相同宽度的区间，区间的个数由数据本身的特点决定或者用户指定，与制作频率分布表类似。pandas提供了cut函数，可以进行连续型数据的等宽离散化，其基础语法格式如下。
- 使用等宽法离散化的缺陷为：等宽法离散化对数据分布具有较高要求，若数据分布不均匀，那么各个类的数目也会变得非常不均匀，有些区间包含许多数据，而另外一些区间的数据极少，这会严重损坏所建立的模型。
- *pandas.***cut***(x, bins, right=True, labels=None,* *retbins**=False, precision=3,* *include_lowest**=False)*

| **参数名称**  | **说明**                                                     |
| ------------- | ------------------------------------------------------------ |
| **x**         | 接收数组或Series。代表需要进行离散化处理的数据。无默认。     |
| **bins**      | 接收int，list，array，tuple。若为int，代表离散化后的类别数目；若为序列类型的数据，则表示进行切分的区间，每两个数间隔为一个区间。无默认。 |
| **right**     | 接收boolean。代表右侧是否为闭区间。默认为True。              |
| **labels**    | 接收list，array。代表离散化后各个类别的名称。默认为空。      |
| **retbins**   | 接收boolean。代表是否返回区间标签。默认为False。             |
| **precision** | 接收int。显示的标签的精度。默认为3。                         |

```python
pd.cut(data['amounts'],bins=5) #切分成五类【分布不均匀】
```

##### 1.2.2 等频法

- cut函数虽然不能够直接实现等频离散化，但是可以通过定义将相同数量的记录放进每个区间。

- 等频法离散化的方法相比较于等宽法离散化而言，避免了类分布不均匀的问题，但同时却也有可能将数值非常接近的两个值分到不同的区间以满足每个区间中固定的数据个数。

```python
def samefreq(data,k):
    w = data.quantile(np.arange(0,1+1/k,1/k))#步长：1/k
    return pd.cut(data,w)
samefreq(data['amounts'],k=5) #等频法
samefreq(data['amounts'],k=5).value_counts() #数据统计（等频法）
```

##### 1.2.3 聚类分析方法

- 一维聚类的方法包括两个步骤：
  - 将连续型数据用聚类算法（如K-Means算法等）进行聚类。
  - 处理聚类得到的簇，将合并到一个簇的连续型数据做同一标记。

- 聚类分析的离散化方法需要用户指定簇的个数，用来决定产生的区间数。

- k-Means聚类分析的离散化方法可以很好地根据现有特征的数据分布状况进行聚类，但是由于k-Means算法本身的缺陷，用该方法进行离散化时依旧需要指定离散化后类别的数目。此时需要配合聚类算法评价方法，找出最优的聚类簇数目。
