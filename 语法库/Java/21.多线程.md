### 一、多线程

#### 1.1 定义

- 程序：Program,是一个指令的集合
- 进程（大老板）：Process（正在执行的程序），可以有多个线程，同一进程的线程之间资源共享。
- 线程（小员工）：被称为“轻量级进程”，是进程中一个“单一的连续控制流程”
- 多线程的缺点：内存的浪费，cpu的负担

说明：进程由cpu,data,code组成。

#### 1.2 实现步骤

方法 一（继承Thread类）：

1. 继承Thread类
2. 重写run()方法
3. 通过start()方法，启动线程。

缺点：一旦继承了Thread类，无法继承其他类了（Java是单继承的）



方法二 （实现接口Runnable）：

1. 编写类实现Runnable接口
2. 实现run()方法
3. 通过Thread类的start()方法，启动线程。

#### 1.3 线程状态（五种状态）

![image-20200313233944516](C:\Users\tiger\AppData\Roaming\Typora\typora-user-images\image-20200313233944516.png)

- 新生状态：
  用 new 关键字建立一个线程后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用 start()方法进入就绪状态。 
- 就绪状态：
  处于就绪状态线程具备了运行条件，但还没分配到 CPU， 处于线程就绪队列，等待系统为其分配 CPU。当系统选定一个等待执行的线程后，它就会从就绪状态进入执行状态，该 动作称为“CPU 调度”。 
- 运行状态：
  在运行状态的线程执行自己的 run 方法中代码,直到等待某资源而阻塞或完成而进入死亡状态。如果在给定的时间片内没有执行结束，就会被系统给换下来回到等待执行状态。 
- 阻塞状态：
  处于运行状态的线程在某些情况下，如执行了 sleep(睡眠) 方法，或等待 I/O 设备等资源，将让出 CPU 并暂时停止自己运行，进入阻塞状态。在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的 I/O 设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续执行。
- 死亡状态：
  死亡状态是线程生命周期中的最后一个阶段。线程死亡的原因有三个，一个是正常运行的线程完成了它的全部工作； 另一个是线程被强制性地终止，如通过 stop 方法来终止一个 线程【不推荐使用】；三是线程抛出未捕获的异常。

#### 1.4 Thread常用方法

![image-20200313234120428](C:\Users\tiger\AppData\Roaming\Typora\typora-user-images\image-20200313234120428.png)

#### 1.5 暂停线程

![image-20200313234327958](C:\Users\tiger\AppData\Roaming\Typora\typora-user-images\image-20200313234327958.png)

- sleep：不会释放锁，Sleep时别的线程也不可以访问锁定对象。
- yield：让出CPU的使用权，从运行态直接进入就绪态。让CPU 重新挑选哪一个线程进入运行态。 
- join：当某个线程等待另一个线程执行结束后，才继续执行时，使调用该方法的线程在此之前执行完毕，也就是等待调 用该方法的线程执行完毕后再往下继续执行 

#### 1.6 优先级

![image-20200313234953098](C:\Users\tiger\AppData\Roaming\Typora\typora-user-images\image-20200313234953098.png)

#### 1.7 线程同步

同步代码块：

```java
  synchronized(obj){           
      //中的 obj 称为同步监视器 
  }
```

同步方法：

```java
public  synchronized …方法名(参数列表){ 
 
} 
```

说明：同步监视器只能是对象，推荐使用共享资源的对象,可以当前 对象 this,也可以是其它的对象。

#### 1.8 死锁

原因：互相等待对方的资源（多线程情况下）

![image-20200313235659356](C:\Users\tiger\AppData\Roaming\Typora\typora-user-images\image-20200313235659356.png)

**解决死锁**：不要让两个对象同时持有对象锁，采用互斥方式来解决 。

**银行家算法**：该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生。（计算资源的大小，计算出来后，永远 按照从大到小的方式来获得锁

#### 1.9 生产者与消费者（线程同步）

![image-20200314000302900](C:\Users\tiger\AppData\Roaming\Typora\typora-user-images\image-20200314000302900.png)

- wait():调用了 wait()方法的线程进入等待池进行等待，等待 池中的线程不去竞争对象锁,直到其它的线程通知，才会进入锁池。

- notify():随机唤醒一个在该对象上等待的线程，被唤醒的线 程进行锁池，开始竞争该锁池上的锁。

- notifyAll():唤醒所有在该对象上等待的线程 优先级高的线程有可能先竞争到对象锁 只能在同步方法和同步代码块中使用